const express = require('express');
const router = express.Router();
const Database = require('better-sqlite3');
const path = require('path');

const dbPath = path.join(__dirname, '..', 'valet.db');
const db = new Database(dbPath);

// Health check
router.get('/health', (req, res) => {
  res.json({ 
    success: true, 
    message: 'API is running',
    timestamp: new Date().toISOString()
  });
});

// Get statistics
router.get('/stats', (req, res) => {
  try {
    const parkedCount = db.prepare('SELECT COUNT(*) as count FROM vehicles WHERE status = ?').get('parked');
    const totalCount = db.prepare('SELECT COUNT(*) as count FROM vehicles').get();
    
    res.json({
      success: true,
      parked: parkedCount.count,
      total: totalCount.count
    });
  } catch (error) {
    console.error('Error getting stats:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Check-in vehicle
router.post('/checkin', (req, res) => {
  const hookManager = req.app.get('hookManager');
  const db = req.app.get('db');
  
  try {
    const { unique_card_id, license_plate, make, model, color, year, parking_spot, key_slot } = req.body;
    
    console.log('âœ… Check-in request:', { unique_card_id, license_plate, make, model, key_slot });

    const stmt = db.prepare(`
      INSERT INTO vehicles (unique_card_id, license_plate, make, model, color, year, parking_spot, key_slot, status, check_in_time)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'parked', datetime('now'))
    `);
    
    const result = stmt.run(unique_card_id, license_plate, make, model, color, year, parking_spot, key_slot);
    const vehicleId = result.lastInsertRowid;
    
    // Assign the hook as occupied
    if (key_slot) {
      hookManager.assignHook(key_slot, vehicleId);
      console.log(`âœ… Hook ${key_slot} assigned to vehicle ${vehicleId}`);
    }
    
    console.log('âœ… Vehicle checked in successfully:', vehicleId);

    // Emit real-time update
    const io = req.app.get('io');
    if (io) {
      io.emit('vehicleCheckedIn', { vehicleId, hookNumber: key_slot });
      io.emit('statsUpdated', {});
    }

    res.json({
      success: true,
      message: 'Vehicle checked in successfully',
      vehicleId: vehicleId,
      vehicle: {
        id: vehicleId,
        unique_card_id,
        license_plate,
        make,
        model,
        color,
        hook_number: key_slot,
        status: 'PARKED'
      }
    });
  } catch (error) {
    console.error('âŒ Error checking in vehicle:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Get all vehicles
router.get('/vehicles', (req, res) => {
  try {
    const vehicles = db.prepare('SELECT * FROM vehicles WHERE status = ? ORDER BY check_in_time DESC').all('parked');
    res.json({ success: true, vehicles });
  } catch (error) {
    console.error('Error getting vehicles:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Request vehicle retrieval
router.post('/request', (req, res) => {
  try {
    const { unique_card_id, is_priority } = req.body;
    
    console.log('ðŸš— Retrieval request:', { unique_card_id, is_priority });

    const vehicle = db.prepare('SELECT * FROM vehicles WHERE unique_card_id = ? AND status = ?').get(unique_card_id, 'parked');
    
    if (!vehicle) {
      return res.status(404).json({ success: false, message: 'Vehicle not found or already retrieved' });
    }

    const stmt = db.prepare(`
      INSERT INTO requests (unique_card_id, is_priority, payment_method, status, requested_at)
      VALUES (?, ?, 'pay_at_counter', 'pending', datetime('now'))
    `);
    
    const result = stmt.run(unique_card_id, is_priority ? 1 : 0);
    
    console.log('âœ… Request created:', result.lastInsertRowid);

    res.json({
      success: true,
      message: 'Retrieval request created',
      requestId: result.lastInsertRowid,
      vehicle: vehicle
    });
  } catch (error) {
    console.error('âŒ Error creating request:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Get retrieval queue
router.get('/queue', (req, res) => {
  try {
    const requests = db.prepare(`
      SELECT 
        r.*,
        v.license_plate,
        v.make,
        v.model,
        v.color,
        v.hook_number
      FROM requests r
      JOIN vehicles v ON r.unique_card_id = v.unique_card_id
      WHERE r.status = 'pending'
      ORDER BY r.is_priority DESC, r.requested_at ASC
    `).all();

    res.json({ success: true, requests });
  } catch (error) {
    console.error('Error getting queue:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

module.exports = router;

// Complete retrieval - update vehicle and request status
router.post('/complete-retrieval', (req, res) => {
  const db = req.app.get('db');
  const hookManager = req.app.get('hookManager');
  
  try {
    const { requestId, cardId, driverId } = req.body;
    
    console.log('ðŸ“¦ Completing retrieval:', { requestId, cardId, driverId });

    // Update vehicle status to 'retrieved'
    const vehicleStmt = db.prepare(`
      UPDATE vehicles 
      SET status = 'retrieved', 
          check_out_time = datetime('now')
      WHERE unique_card_id = ?
    `);
    vehicleStmt.run(cardId);
    
    // Get the vehicle's hook number to release it
    const vehicle = db.prepare('SELECT key_slot FROM vehicles WHERE unique_card_id = ?').get(cardId);
    
    // Release the hook
    if (vehicle && vehicle.key_slot) {
      hookManager.releaseHook(vehicle.key_slot);
      console.log(`âœ… Hook ${vehicle.key_slot} released`);
    }

    // Update request status to 'completed'
    const requestStmt = db.prepare(`
      UPDATE requests 
      SET status = 'completed',
          assigned_driver_id = ?,
          completed_at = datetime('now')
      WHERE id = ?
    `);
    requestStmt.run(driverId, requestId);
    
    console.log('âœ… Retrieval completed successfully');

    // Emit real-time update
    const io = req.app.get('io');
    if (io) {
      io.emit('retrievalCompleted', { requestId, cardId });
      io.emit('statsUpdated', {});
    }

    res.json({
      success: true,
      message: 'Retrieval completed successfully'
    });
  } catch (error) {
    console.error('âŒ Error completing retrieval:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// ============================================
// STATION DASHBOARD ENDPOINTS
// ============================================

// Get station overview - current status
router.get('/station/overview', (req, res) => {
  const db = req.app.get('db');
  
  try {
    const totalParked = db.prepare(
      "SELECT COUNT(*) as count FROM vehicles WHERE status = 'parked'"
    ).get().count;
    
    const totalRetrieving = db.prepare(
      "SELECT COUNT(*) as count FROM requests WHERE status = 'pending'"
    ).get().count;
    
    const availableDrivers = db.prepare(
      "SELECT COUNT(*) as count FROM drivers WHERE status = 'available'"
    ).get().count || 0;
    
    const busyDrivers = db.prepare(
      "SELECT COUNT(*) as count FROM drivers WHERE status = 'busy'"
    ).get().count || 0;
    
    res.json({
      success: true,
      stats: { totalParked, totalRetrieving, availableDrivers, busyDrivers }
    });
  } catch (error) {
    console.error('Error getting station overview:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Get daily stats
router.get('/station/daily-stats', (req, res) => {
  const db = req.app.get('db');
  
  try {
    const totalDropOffs = db.prepare(`
      SELECT COUNT(*) as count FROM vehicles 
      WHERE DATE(check_in_time) = DATE('now')
    `).get().count;
    
    const totalPickups = db.prepare(`
      SELECT COUNT(*) as count FROM requests 
      WHERE DATE(car_ready_at) = DATE('now') AND car_ready_at IS NOT NULL
    `).get().count;
    
    const waitTimeData = db.prepare(`
      SELECT AVG((JULIANDAY(car_ready_at) - JULIANDAY(requested_at)) * 24 * 60) as avg_wait
      FROM requests 
      WHERE DATE(car_ready_at) = DATE('now') AND car_ready_at IS NOT NULL
    `).get();
    
    const revenueData = db.prepare(`
      SELECT COALESCE(SUM(amount), 0) as total FROM requests 
      WHERE DATE(car_ready_at) = DATE('now') AND car_ready_at IS NOT NULL AND payment_processed = 1
    `).get();
    
    res.json({
      success: true,
      stats: {
        totalDropOffs,
        totalPickups,
        averageWaitTime: Math.round(waitTimeData.avg_wait || 0),
        revenue: revenueData.total || 0
      }
    });
  } catch (error) {
    console.error('Error getting daily stats:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});


// ============================================
// PREMIUM WORKFLOW ENDPOINTS
// ============================================

// Mark car as ready (driver pressed "Got the Car")
router.post('/retrieval/:id/car-ready', (req, res) => {
  const db = req.app.get('db');
  const { id } = req.params;
  const { driverId } = req.body;

  try {
    const stmt = db.prepare(`
      UPDATE requests 
      SET car_ready_at = datetime('now')
      WHERE id = ?
    `);
    stmt.run(id);

    // Get request details
    const request = db.prepare('SELECT * FROM requests WHERE id = ?').get(id);

    // Emit socket event
    const io = req.app.get('io');
    if (io) {
      io.emit('carReady', { 
        requestId: id, 
        cardId: request.unique_card_id,
        timestamp: new Date().toISOString()
      });
      console.log('ðŸ“¡ Car ready notification sent');
    }

    res.json({
      success: true,
      message: 'Car marked as ready',
      request
    });
  } catch (error) {
    console.error('Error marking car ready:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Collect cash payment (station attendant)
router.post('/retrieval/:id/collect-cash', (req, res) => {
  const db = req.app.get('db');
  const { id } = req.params;
  const { collectedBy, amount, tipAmount } = req.body;

  try {
    const stmt = db.prepare(`
      UPDATE requests 
      SET payment_status = 'cash_collected',
          amount = ?,
          tip_amount = ?,
          payment_collected_by = ?,
          payment_processed = 1
      WHERE id = ?
    `);
    stmt.run(amount, tipAmount || 0, collectedBy, id);

    // Emit socket event
    const io = req.app.get('io');
    if (io) {
      io.emit('cashCollected', { 
        requestId: id, 
        collectedBy,
        amount: parseFloat(amount) + parseFloat(tipAmount || 0)
      });
      console.log('ðŸ“¡ Cash collected notification sent');
    }

    res.json({
      success: true,
      message: 'Cash payment collected'
    });
  } catch (error) {
    console.error('Error collecting cash:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Hand over keys (final step)
router.post('/retrieval/:id/handover-keys', (req, res) => {
  const db = req.app.get('db');
  const { id } = req.params;
  const { handedBy } = req.body;

  try {
    const stmt = db.prepare(`
      UPDATE requests 
      SET keys_handed_at = datetime('now'),
          status = 'completed',
          completed_at = datetime('now')
      WHERE id = ?
    `);
    stmt.run(id);

    // Get request details for vehicle update
    const request = db.prepare('SELECT * FROM requests WHERE id = ?').get(id);
    
    // Update vehicle status
    db.prepare(`
      UPDATE vehicles 
      SET status = 'retrieved',
          check_out_time = datetime('now')
      WHERE unique_card_id = ?
    `).run(request.unique_card_id);

    // Emit socket event
    const io = req.app.get('io');
    if (io) {
      io.emit('keysHanded', { 
        requestId: id,
        cardId: request.unique_card_id,
        timestamp: new Date().toISOString()
      });
      io.emit('statsUpdated', {});
      console.log('ðŸ“¡ Keys handed notification sent');
    }

    res.json({
      success: true,
      message: 'Keys handed over, transaction completed'
    });
  } catch (error) {
    console.error('Error handing over keys:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Get cash pending requests (for station cash tab)
router.get('/station/cash-pending', (req, res) => {
  const db = req.app.get('db');

  try {
    const requests = db.prepare(`
      SELECT 
        rr.*,
        v.make, v.model, v.color, v.license_plate, v.hook_number,
        d.fullName as driver_name
      FROM requests rr
      JOIN vehicles v ON rr.unique_card_id = v.unique_card_id
      LEFT JOIN drivers d ON rr.assigned_driver_id = d.id
      WHERE rr.payment_status = 'cash_pending'
        AND rr.car_ready_at IS NOT NULL
        AND rr.status != 'completed'
      ORDER BY rr.car_ready_at ASC
    `).all();

    res.json({
      success: true,
      requests
    });
  } catch (error) {
    console.error('Error getting cash pending requests:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Update request to set payment method
router.post('/retrieval/:id/payment-method', (req, res) => {
  const db = req.app.get('db');
  const { id } = req.params;
  const { paymentMethod } = req.body;

  try {
    const paymentStatus = paymentMethod === 'online' ? 'paid_online' : 'cash_pending';
    
    const stmt = db.prepare(`
      UPDATE requests 
      SET payment_method = ?,
          payment_status = ?
      WHERE id = ?
    `);
    stmt.run(paymentMethod, paymentStatus, id);

    res.json({
      success: true,
      message: 'Payment method updated',
      paymentStatus
    });
  } catch (error) {
    console.error('Error updating payment method:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});


// ============================================
// PRICING MANAGEMENT ENDPOINTS
// ============================================

// Get current pricing
router.get('/pricing', (req, res) => {
  const db = req.app.get('db');
  
  try {
    const pricing = db.prepare('SELECT * FROM pricing_settings ORDER BY id DESC LIMIT 1').get();
    
    if (!pricing) {
      return res.json({
        success: true,
        pricing: {
          base_valet_fee: 15.00,
          surge_multiplier: 1.0,
          is_surge_active: 0,
          current_price: 15.00
        }
      });
    }

    const currentPrice = pricing.base_valet_fee * (pricing.is_surge_active ? pricing.surge_multiplier : 1.0);
    
    res.json({
      success: true,
      pricing: {
        ...pricing,
        current_price: parseFloat(currentPrice.toFixed(2))
      }
    });
  } catch (error) {
    console.error('Error getting pricing:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Update pricing
router.post('/pricing/update', (req, res) => {
  const db = req.app.get('db');
  const { base_valet_fee, surge_multiplier, is_surge_active, updated_by } = req.body;
  
  try {
    const stmt = db.prepare(`
      INSERT INTO pricing_settings (base_valet_fee, surge_multiplier, is_surge_active, updated_by, updated_at)
      VALUES (?, ?, ?, ?, datetime('now'))
    `);
    
    stmt.run(
      base_valet_fee || 15.00,
      surge_multiplier || 1.0,
      is_surge_active ? 1 : 0,
      updated_by || 'Station'
    );

    const currentPrice = base_valet_fee * (is_surge_active ? surge_multiplier : 1.0);

    // Emit pricing update via WebSocket
    const io = req.app.get('io');
    if (io) {
      io.emit('pricingUpdated', {
        base_valet_fee,
        surge_multiplier,
        is_surge_active,
        current_price: parseFloat(currentPrice.toFixed(2))
      });
    }

    res.json({
      success: true,
      message: 'Pricing updated successfully',
      current_price: parseFloat(currentPrice.toFixed(2))
    });
  } catch (error) {
    console.error('Error updating pricing:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});


// ============================================
// DRIVER STATUS ENDPOINTS
// ============================================

// Update driver status (online/offline)
router.post('/driver/:id/status', (req, res) => {
  const db = req.app.get('db');
  const { id } = req.params;
  const { status } = req.body; // 'available', 'busy', 'offline'

  try {
    const stmt = db.prepare('UPDATE drivers SET status = ? WHERE id = ?');
    stmt.run(status, id);

    // Emit status change via WebSocket
    const io = req.app.get('io');
    if (io) {
      io.emit('driverStatusChanged', { driverId: id, status });
      console.log(`ðŸ“¡ Driver ${id} status changed to ${status}`);
    }

    res.json({
      success: true,
      message: `Driver status updated to ${status}`
    });
  } catch (error) {
    console.error('Error updating driver status:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

// Driver logout
router.post('/driver/logout', (req, res) => {
  const db = req.app.get('db');
  const { driverId } = req.body;

  try {
    if (driverId) {
      const stmt = db.prepare('UPDATE drivers SET status = ? WHERE id = ?');
      stmt.run('offline', driverId);

      // Emit status change
      const io = req.app.get('io');
      if (io) {
        io.emit('driverStatusChanged', { driverId, status: 'offline' });
      }
    }

    res.json({
      success: true,
      message: 'Logged out successfully'
    });
  } catch (error) {
    console.error('Error logging out:', error);
    res.status(500).json({ success: false, message: error.message });
  }
});

